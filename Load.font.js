// Generated by CoffeeScript 1.3.3

/*

     __                           __          ___               __
    /\ \                         /\ \       /'___\             /\ \__
    \ \ \        ___      __     \_\ \     /\ \__/  ___     ___\ \ ,_\   ____
     \ \ \  __  / __`\  /'__`\   /'_` \    \ \ ,__\/ __`\ /' _ `\ \ \/  /',__\
      \ \ \L\ \/\ \L\ \/\ \L\.\_/\ \L\ \  __\ \ \_/\ \L\ \/\ \/\ \ \ \_/\__, `\
       \ \____/\ \____/\ \__/.\_\ \___,_\/\_\\ \_\\ \____/\ \_\ \_\ \__\/\____/
        \/___/  \/___/  \/__/\/_/\/__,_ /\/_/ \/_/ \/___/  \/_/\/_/\/__/\/___/


    ===========================================================================
    ---------------------------------------------------------------------------

    Load.fonts v1.0.0 – 21 August, 2012

    (c) Amsul Naeem, 2012
    Licensed under MIT ("expat" flavour) license.
    Hosted on http://github.com/amsul/Load.fonts

    A fork of Font.js v2012.01.25: https://github.com/Pomax/Font.js

    This library adds Font objects to the general pool
    of available JavaScript objects, so that you can load
    fonts through a JavaScript object similar to loading
    images through a new Image() object.

    Load.fonts is compatible with all browsers that support
    <canvas> and Object.defineProperty - This includes
    all versions of Firefox, Chrome, Opera, IE and Safari
    that were 'current' (Firefox 9, Chrome 16, Opera 11.6,
    IE9, Safari 5.1) at the time Font.js was released.

    Load.fonts will not work on IE8 or below due to the lack
    of Object.defineProperty - I recommend using the
    solution outlined in http://ie6update.com/ for websites
    that are not corporate intranet sites, because as a home
    user you have no excuse not to have upgraded to Internet
    Explorer 9 yet, or simply not using Internet Explorer if
    you're still using Windows XP. If you have friends or
    family that still use IE8 or below: intervene.

    You may remove every line in this header except for
    the first block of four lines, for the purposes of
    saving space and minification. If minification strips
    the header, you'll have to paste that paragraph back in.

    Issue tracker: https://github.com/amsul/Load.fonts/issues
*/


/*jshint debug: true, browser: true, devel: true, curly: false, forin: false, nonew: true, plusplus: false, bitwise: false
*/


(function() {
  var Font;

  Font = (function() {
    var self;

    function Font() {}

    self = {};

    /*
        Check browser support
        ========================================================================
    */


    self.checkSupport = function() {
      var supportsTypedArrays, supportsXHRTyping;
      supportsTypedArrays = (function() {
        var TypedArray, a, set_, subarray;
        try {
          a = new Uint8Array(1);
          return;
        } catch (error) {
          return;
        }
        subarray = function(start, end) {
          return this.slice(start, end);
        };
        set_ = function(array, offset) {
          var item, _i, _len;
          if (arguments.length < 2) {
            offset = 0;
          }
          for (_i = 0, _len = array.length; _i < _len; _i++) {
            item = array[_i];
            this[offset] = item & 0xFF;
            offset += 1;
          }
        };
        TypedArray = function(argument) {
          var i, result;
          if (typeof argument === 'number') {
            result = new Array(argument);
            i = 0;
            while (argument > i) {
              result[i] = 0;
              i += 1;
            }
          } else {
            result = argument.slice(0);
          }
          result.subarray = subarray;
          result.buffer = result;
          result.byteLength = result.length;
          result.set = set_;
          if (typeof argument === 'object' && argument.buffer) {
            result.buffer = argument.buffer;
          }
          return result;
        };
        window.Uint8Array = TypedArray;
        window.Uint32Array = TypedArray;
        window.Int32Array = TypedArray;
      })();
      supportsXHRTyping = (function() {
        var getter;
        if (window.opera || ('response' in XMLHttpRequest.prototype) || ('mozResponseArrayBuffer' in XMLHttpRequest.prototype) || ('mozResponse' in XMLHttpRequest.prototype) || ('responseArrayBuffer' in XMLHttpRequest.prototype)) {
          return;
        }
        if (window.VBArray) {
          getter = function() {
            return new Uint8Array(new VBArray(this.responseBody).toArray());
          };
        } else {
          getter = function() {
            return this.responseBody;
          };
        }
        try {
          Object.defineProperty(XMLHttpRequest.prototype, 'response', {
            get: getter
          });
        } catch (error) {

        }
      })();
      if (!window.btoa) {
        window.btoa = function(data) {
          var ac, b64, bits, enc, h, h1, h2, h3, h4, i, o1, o2, o3, r, tmp_arr;
          o1 = void 0;
          o2 = void 0;
          o3 = void 0;
          bits = void 0;
          h1 = void 0;
          h2 = void 0;
          h3 = void 0;
          h4 = void 0;
          b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          i = 0;
          ac = 0;
          enc = '';
          tmp_arr = [];
          if (!data) {
            return data;
          }
          do {
                    o1 = data.charCodeAt(i++)
                    o2 = data.charCodeAt(i++)
                    o3 = data.charCodeAt(i++)
                    bits = o1 << 16 | o2 << 8 | o3
                    h1 = bits >> 18 & 0x3f
                    h2 = bits >> 12 & 0x3f
                    h3 = bits >> 6 & 0x3f
                    h4 = bits & 0x3f
                    // use hexets to index into b64, and append result to encoded string
                    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4)
                } while ( i < data.length );

          enc = tmp_arr.join('');
          r = data.length % 3;
          h = r ? enc.slice(0, r - 3) : enc;
          return (r ? enc.slice(0, r - 3) : enc) + "===".slice(r || 3);
        };
      }
      return self;
    };

    /*
        Initialize the Font class
        ========================================================================
    */


    self.initialize = (function() {
      self.checkSupport();
      if (!Object.defineProperty) {
        throw 'Load.font.js requires Object.defineProperty, which this browser does not support.';
      }
      if (!document.createElement('canvas').getContext) {
        throw 'Load.font.js requires <canvas> and the Canvas2D API, which this browser does not support.';
      }
      Font.prototype.fontFamily = 'lfjs' + (999999 * Math.random() | 0);
      Font.prototype.url = '';
      Font.prototype.format = '';
      Font.prototype.data = '';
      Font.prototype.base64 = 'AAEAAAAKAIAAAwAgT1MvMgAAAAAAAACsAAAAWGNtYXAAAAAAAAABBAAAACxnbHlmAAAAAAAAATAAAAAQaGVhZAAAAAAAAAFAAAAAOGhoZWEAAAAAAAABeAAAACRobXR4AAAAAAAAAZwAAAAIbG9jYQAAAAAAAAGkAAAACG1heHAAAAAAAAABrAAAACBuYW1lAAAAAAAAAcwAAAAgcG9zdAAAAAAAAAHsAAAAEAAEAAEAZAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAABAAMAAQAAAAwABAAgAAAABAAEAAEAAABB//8AAABB////wAABAAAAAAABAAAAAAAAAAAAAAAAMQAAAQAAAAAAAAAAAABfDzz1AAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAEAAgAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAIAAAAAQAAAAIAAQABAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAIAHgADAAEECQABAAAAAAADAAEECQACAAIAAAAAAAEAAAAAAAAAAAAAAAAAAA==';
      Font.prototype.metrics = {
        quadsize: 0,
        leading: 0,
        ascent: 0,
        descent: 0,
        weightclass: 400
      };
      Font.prototype.systemfont = false;
      Font.prototype.loaded = false;
      Font.prototype.onload = function() {};
      Font.prototype.onerror = function() {};
      Font.prototype.canvas = false;
      Font.prototype.context = false;
      Font.prototype.validate = function(target, zero, mark, font, timeout) {
        var callback, computedStyle, width;
        if (timeout !== false && timeout < 0) {
          this.onerror('Requested system font \'' + this.fontFamily + '\' could not be loaded (it may not be installed).');
          return;
        }
        computedStyle = document.defaultView.getComputedStyle(target, '');
        width = computedStyle.getPropertyValue('width').replace('px', '');
        if (width > 0) {
          document.head.removeChild(zero);
          document.body.removeChild(target);
          this.loaded = true;
          this.onload();
        } else {
          callback = function() {
            font.validate(target, zero, mark, font, timeout === false ? false : timeout - 50);
          };
          setTimeout(callback, 50);
        }
      };
      Font.prototype.ondownloaded = function() {
        var cff, checkEncoding, checkTableError, chr, chr16, cmap314, createTags, data, dechex, delta, e, encodingRecord, end, endChar, error, fword, i, isCFF, isTTF, newhex, numTables, printChar, printable, ptr, segCount, tag, tagStart, tags, ttf, ulong, unitsPerEm, ushort, version, _i;
        chr = function(val) {
          return String.fromCharCode(val);
        };
        chr16 = function(val) {
          var b1, b2;
          if (val < 256) {
            return chr(0) + chr(val);
          }
          b1 = val >> 8;
          b2 = val & 0xFF;
          return chr(b1) + chr(b2);
        };
        dechex = function(val) {
          if (val < 0) {
            val = 0xFFFFFFFF + val + 1;
          }
          return parseInt(val, 10).toString(16);
        };
        ushort = function(b1, b2) {
          return 256 * b1 + b2;
        };
        fword = function(b1, b2) {
          var negative, val;
          negative = b1 >> 7 === 1;
          b1 = b1 & 0x7F;
          val = 256 * b1 + b2;
          if (!negative) {
            return val;
          }
          return val - 0x8000;
        };
        ulong = function(b1, b2, b3, b4) {
          return 16777216 * b1 + 65536 * b2 + 256 * b3 + b4;
        };
        error = function(msg) {
          this.onerror(msg);
        };
        ttf = chr(0) + chr(1) + chr(0) + chr(0);
        cff = 'OTTO';
        data = this.data;
        version = chr(data[0]) + chr(data[1]) + chr(data[2]) + chr(data[3]);
        isTTF = version === ttf;
        isCFF = isTTF ? false : version === cff;
        if (isTTF) {
          this.format = 'truetype';
        } else if (isCFF) {
          this.format = 'opentype';
        } else {
          error('Error: file at ' + this.url + ' cannot be interpreted as OpenType font.');
        }
        /*
                    if we get here, this is a legal font. Extract some font metrics,
                    and then wait for the font to be available for on-page styling.
        */

        numTables = ushort(data[4], data[5]);
        tagStart = 12;
        end = tagStart + 16 * numTables;
        tags = {};
        createTags = function(ptr) {
          var tag;
          tag = chr(data[ptr]) + chr(data[ptr + 1]) + chr(data[ptr + 2]) + chr(data[ptr + 3]);
          tags[tag] = {
            name: tag,
            checksum: ulong(data[ptr + 4], data[ptr + 5], data[ptr + 6], data[ptr + 7]),
            offset: ulong(data[ptr + 8], data[ptr + 9], data[ptr + 10], data[ptr + 11]),
            length: ulong(data[ptr + 12], data[ptr + 13], data[ptr + 14], data[ptr + 15])
          };
        };
        for (ptr = _i = tagStart; _i < end; ptr = _i += 16) {
          createTags(ptr);
        }
        checkTableError = function(tag) {
          if (!tags[tag]) {
            error('Error: font is missing the required OpenType \'' + tag + '\' table.');
            return false;
          }
          return tag;
        };
        tag = checkTableError('head');
        if (tag === false) {
          return;
        }
        ptr = tags[tag].offset;
        tags[tag].version = '' + data[ptr] + data[ptr + 1] + data[ptr + 2] + data[ptr + 3];
        unitsPerEm = ushort(data[ptr + 18], data[ptr + 19]);
        this.metrics.quadsize = unitsPerEm;
        tag = checkTableError('hhea');
        if (tag === false) {
          return;
        }
        ptr = tags[tag].offset;
        tags[tag].version = '' + data[ptr] + data[ptr + 1] + data[ptr + 2] + data[ptr + 3];
        this.metrics.ascent = fword(data[ptr + 4], data[ptr + 5]) / unitsPerEm;
        this.metrics.descent = fword(data[ptr + 6], data[ptr + 7]) / unitsPerEm;
        this.metrics.leading = fword(data[ptr + 8], data[ptr + 9]) / unitsPerEm;
        tag = checkTableError('OS/2');
        if (tag === false) {
          return;
        }
        ptr = tags[tag].offset;
        tags[tag].version = '' + data[ptr] + data[ptr + 1];
        this.metrics.weightclass = ushort(data[ptr + 4], data[ptr + 5]);
        /*
                    Then the mechanism for determining whether the font is not
                    just done downloading, but also fully parsed and ready for
                    use on the page for typesetting: we pick a letter that we know
                    is supported by the font, and generate a font that implements
                    only that letter, as a zero-width glyph. We can then test
                    whether the font is available by checking whether a paragraph
                    consisting of just that letter, styled with "desiredfont, zwfont"
                    has zero width, or a real width. As long as it's zero width, the
                    font has not finished loading yet.
        */

        tag = checkTableError('cmap');
        if (tag === false) {
          return;
        }
        ptr = tags[tag].offset;
        tags[tag].version = '' + data[ptr] + data[ptr + 1];
        numTables = ushort(data[ptr + 2], data[ptr + 3]);
        cmap314 = false;
        checkEncoding = function() {
          var encodingID, offset, platformID, rptr;
          rptr = ptr + 4 + encodingRecord * 8;
          platformID = ushort(data[rptr], data[rptr + 1]);
          encodingID = ushort(data[rptr + 2], data[rptr + 3]);
          offset = ulong(data[rptr + 4], data[rptr + 5], data[rptr + 6], data[rptr + 7]);
          if (platformID === 3 && encodingID === 1) {
            cmap314 = offset;
          }
        };
        encodingRecord = 0;
        while (encodingRecord < numTables) {
          checkEncoding();
          encodingRecord += 1;
        }
        printChar = 'A';
        if (cmap314 !== false) {
          ptr += cmap314;
          version = ushort(data[ptr], data[ptr + 1]);
          if (version === 4) {
            segCount = ushort(data[ptr + 6], data[ptr + 7]) / 2;
            printable = function(chr) {
              return [0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x0020, 0x0085, 0x00A0, 0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x2028, 0x2029, 0x202F, 0x205F, 0x3000].indexOf(chr) === -1;
            };
            i = ptr + 14;
            e = ptr + 14 + 2 * segCount;
            endChar = false;
            while (i < e) {
              endChar = ushort(data[i], data[i + 1]);
              if (printable(endChar)) {
                break;
              }
              endChar = false;
              i += 2;
            }
            if (endChar !== false) {
              printChar = String.fromCharCode(endChar);
              delta = -(endChar - 1) + 65536;
              newhex = btoa(window.unescape(encodeURIComponent(chr(0) + chr16(endChar) + chr16(0xFFFF) + chr16(0) + chr16(endChar) + chr16(0xFFFF) + chr16(delta) + chr16(1))));
              this.base64 = this.base64.substring(0, 380) + newhex + this.base64.substring(380 + newhex.length);
            }
          }
        }
        this.bootstrapValidation(printChar, false);
      };
      Font.prototype.bootstrapValidation = function(printChar, timeout) {
        var canvas, context, delayedValidate, error, local, para, quad, realfont, tfName, zerowidth;
        error = function(msg) {
          return this.onerror(msg);
        };
        tfName = this.fontFamily + ' testfont';
        zerowidth = document.createElement('style');
        zerowidth.setAttribute('type', 'text/css');
        zerowidth.innerHTML = '@font-face {\n' + 'font-family: \'' + tfName + '\';\n' + 'src: url(\'data:application/x-font-ttf;base64,' + this.base64 + '\')\n' + 'format(\'truetype\');}';
        document.head.appendChild(zerowidth);
        realfont = false;
        if (!this.systemfont) {
          realfont = this.toStyleNode();
          document.head.appendChild(realfont);
        }
        para = document.createElement('p');
        para.style.cssText = 'position: absolute; top: 0; left: 0; opacity: 0;';
        para.style.fontFamily = '\'' + this.fontFamily + '\', \'' + tfName + '\'';
        para.innerHTML = printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar;
        document.body.appendChild(para);
        if (!document.defaultView.getComputedStyle) {
          this.onload();
          error('Error: document.defaultView.getComputedStyle is not supported by this browser.\n' + 'Consequently, Font.onload() cannot be trusted.');
        } else {
          quad = this.systemfont ? 1000 : this.metrics.quadsize;
          canvas = document.createElement('canvas');
          canvas.width = quad;
          canvas.height = quad;
          this.canvas = canvas;
          context = canvas.getContext('2d');
          context.font = '1em \'' + this.fontFamily + '\'';
          context.fillStyle = 'white';
          context.fillRect(-1, -1, quad + 2, quad + 2);
          context.fillStyle = 'black';
          context.fillText('test text', 50, quad / 2);
          this.context = context;
          local = this;
          delayedValidate = function() {
            local.validate(para, zerowidth, realfont, local, timeout);
          };
          setTimeout(delayedValidate, 50);
        }
      };
      /*
              We take a different path for System fonts, because
              we cannot inspect the actual byte code.
      */

      Font.prototype.processSystemFont = function() {
        this.systemfont = true;
        this.metrics = false;
        this.bootstrapValidation('A', 1000);
      };
      /*
              This gets called when font.src is set, (the binding
              for which is at the end of this file).
      */

      Font.prototype.loadFont = function() {
        var font, xhr;
        font = this;
        if (this.url.indexOf('.') === -1) {
          setTimeout(font.processSystemFont(), 10);
          return;
        }
        xhr = new XMLHttpRequest();
        xhr.open('GET', font.url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function(evt) {
          var arrayBuffer;
          arrayBuffer = xhr.response;
          if (arrayBuffer) {
            font.data = new Uint8Array(arrayBuffer);
            font.ondownloaded();
          } else {
            font.onerror('Error downloading font resource from ' + font.url);
          }
        };
        xhr.send(null);
      };
      Font.prototype.styleNode = false;
      /*
              Get the DOM node associated with this Font
              object, for page-injection.
      */

      Font.prototype.toStyleNode = function() {
        if (this.styleNode) {
          return this.styleNode;
        }
        this.styleNode = document.createElement('style');
        this.styleNode.type = 'text/css';
        this.styleNode.innerHTML = '@font-face {\n' + 'font-family: \'' + this.fontFamily + '\';\n' + 'src: url(\'' + this.url + '\') format(\'' + this.format + '\');\n' + '}';
        return this.styleNode;
      };
      /*
              Measure a specific string of text, given this font.
              If the text is too wide for our preallocated canvas,
              it will be chopped up and the segments measured
              separately.
      */

      Font.prototype.measureText = function(textString, fontSize) {
        var error, i, metrics, minSegments, segmentLength, segments;
        error = function(msg) {
          return this.onerror(msg);
        };
        if (!this.loaded) {
          error('measureText() was called while the font was not yet loaded');
          return false;
        }
        this.context.font = fontSize + 'px \'' + this.fontFamily + '\'';
        metrics = this.context.measureText(textString);
        metrics.fontsize = fontSize;
        metrics.ascent = 0;
        metrics.descent = 0;
        metrics.bounds = {
          minx: 0,
          maxx: metrics.width,
          miny: 0,
          maxy: 0
        };
        metrics.height = 0;
        segments = [];
        minSegments = metrics.width / this.metrics.quadsize;
        if (minSegments <= 1) {
          segments.push(textString);
        } else {
          segments.push(textString);
        }
        i = 0;
        segmentLength = segments.length;
        while (i < segmentLength) {
          this.measureSegment(segments[i], fontSize, metrics);
          i += 1;
        }
        return metrics;
      };
      /*
              Measure a section of text, given this font, that is
              guaranteed to fit on our preallocated canvas.
      */

      Font.prototype.measureSegment = function(textSegment, fontSize, metrics) {
        var ascent, attachSegments, baseline, canvas, ctx, descent, getCSSValue, h, i, j, leadDiv, leadDivHeight, len, maxx, mid, minx, numLines, padding, pixelData, quad, scanheight, scanwidth, step, w, w4, x_offset, xpos, y_offset;
        getCSSValue = function(element, property) {
          return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
        };
        leadDiv = document.createElement('div');
        leadDiv.style.position = 'absolute';
        leadDiv.style.opacity = 0;
        leadDiv.style.font = fontSize + 'px \'' + this.fontFamily + '\'';
        numLines = 10;
        leadDiv.innerHTML = textSegment;
        i = 1;
        attachSegments = function() {
          leadDiv.innerHTML += '<br>' + textSegment;
        };
        while (i < numLines) {
          attachSegments();
          i += 1;
        }
        document.body.appendChild(leadDiv);
        metrics.leading = 1.2 * fontSize;
        leadDivHeight = getCSSValue(leadDiv, 'height');
        leadDivHeight = leadDivHeight.replace('px', '');
        if (leadDivHeight >= fontSize * numLines) {
          metrics.leading = (leadDivHeight / numLines) | 0;
        }
        document.body.removeChild(leadDiv);
        if (/^\s*$/.test(textSegment)) {
          return metrics;
        }
        canvas = this.canvas;
        ctx = this.context;
        quad = this.systemfont ? 1000 : this.metrics.quadsize;
        w = quad;
        h = quad;
        baseline = quad / 2;
        padding = 50;
        xpos = (quad - metrics.width) / 2;
        if (xpos !== (xpos | 0)) {
          xpos = xpos | 0;
        }
        ctx.fillStyle = 'white';
        ctx.fillRect(-padding, -padding, w + 2 * padding, h + 2 * padding);
        ctx.fillStyle = 'black';
        ctx.fillText(textSegment, xpos, baseline);
        scanwidth = (metrics.width + padding) | 0;
        scanheight = 4 * fontSize;
        x_offset = xpos - padding / 2;
        y_offset = baseline - scanheight / 2;
        pixelData = ctx.getImageData(x_offset, y_offset, scanwidth, scanheight).data;
        i = 0;
        j = 0;
        w4 = scanwidth * 4;
        len = pixelData.length;
        mid = scanheight / 2;
        while (++i < len && pixelData[i] === 255) {
          continue;
        }
        ascent = (i / w4) | 0;
        i = len - 1;
        while (--i > 0 && pixelData[i] === 255) {
          continue;
        }
        descent = (i / w4) | 0;
        i = 0;
        j = 0;
        while (j < scanwidth && pixelData[i] === 255) {
          i += w4;
          if (i >= len) {
            j++;
            i = (i - len) + 4;
          }
        }
        minx = j;
        step = 1;
        i = len - 3;
        j = 0;
        while (j < scanwidth && pixelData[i] === 255) {
          i -= w4;
          if (i < 0) {
            j++;
            i = (len - 3) - (step++) * 4;
          }
        }
        maxx = scanwidth - j;
        metrics.ascent = mid - ascent;
        metrics.descent = descent - mid;
        metrics.bounds = {
          minx: minx - (padding / 2),
          maxx: maxx - (padding / 2),
          miny: -metrics.descent,
          maxy: metrics.ascent
        };
        metrics.height = 1 + (descent - ascent);
        return metrics;
      };
      /*
              we want Font to do the same thing Image does when
              we set the "src" property value, so we use the
              Object.defineProperty function to bind a setter
              that does more than just bind values.
      */

      try {
        Object.defineProperty(Font.prototype, 'src', {
          set: function(url) {
            this.url = url;
            return this.loadFont();
          }
        });
      } catch (error) {

      }
      window.Font = Font;
      return self;
    })();

    return Font;

  })();

}).call(this);
